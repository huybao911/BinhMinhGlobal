{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.IntervalState = void 0;\n(function (IntervalState) {\n  IntervalState[IntervalState[\"IDLE\"] = 0] = \"IDLE\";\n  IntervalState[IntervalState[\"RUNNING\"] = 1] = \"RUNNING\";\n  IntervalState[IntervalState[\"PAUSED\"] = 2] = \"PAUSED\";\n  IntervalState[IntervalState[\"RESUME\"] = 3] = \"RESUME\";\n})(exports.IntervalState || (exports.IntervalState = {}));\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nclass IntervalTimer {\n  constructor(\n  /**\n   * Called after every interval.\n   */\n  callback,\n  /**\n   * Time between intervals, in milliseconds.\n   */\n  interval,\n  /**\n   * Maximum amount of fires.\n   */\n  maxFires) {\n    this.callback = callback;\n    this.interval = interval;\n    this.maxFires = maxFires;\n    /**\n     * The state to handle logic.\n     * - 0 means the interval is idle.\n     * - 1 means it's running.\n     * - 2 means it's paused\n     * - 3 will resume.\n     */\n    this.state = exports.IntervalState.IDLE;\n    /**\n     * Remaining time before the next interval.\n     */\n    this.remaining = 0;\n    /**\n     * Amount of times fired.\n     */\n    this.fires = 0;\n    /**\n     * Time passed after pausing,\n     */\n    this.pausedTime = 0;\n    /**\n     * Handles the callback execution, the amount of fires, & the times when fired.\n     * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n     */\n    this.intervalHandler = () => {\n      if (this.maxFires != null && this.fires !== 0 && this.fires >= this.maxFires) {\n        this.stop();\n      } else {\n        this.lastTimeFired = new Date();\n        this.fires += 1;\n        this.callback();\n      }\n    };\n    /**\n     * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n     * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n     */\n    this.timeoutHandler = () => {\n      if (this.state !== exports.IntervalState.RESUME) return;\n      this.pausedTime = 0;\n      this.intervalHandler();\n      this.start();\n    };\n    /**\n     * `start` executes the interval, and saves the interval ID for further use.\n     * The time of execution is also fired in case it's paused later on. The state\n     * is finally set as running.\n     */\n    this.start = () => {\n      this.timerId = setInterval(this.intervalHandler, this.interval);\n      this.lastTimeFired = new Date();\n      this.state = exports.IntervalState.RUNNING;\n    };\n    /**\n     * `stop` clears every respective timeout and interval, then sets the state as idle.\n     */\n    this.stop = () => {\n      if (this.state === 0) return;\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = exports.IntervalState.IDLE;\n    };\n    /**\n     * Resets the interval.\n     */\n    this.reset = () => {\n      this.stop();\n      this.start();\n    };\n    /**\n     * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n     * in a member variable. Afterwards clear the respective timeout and interval then set the new\n     * state.\n     */\n    this.pause = () => {\n      if (this.state !== exports.IntervalState.RUNNING && this.state !== exports.IntervalState.RESUME) return;\n      this.remaining = +this.interval - (+new Date() - +(this.lastTimeFired || 0)) + +this.pausedTime;\n      this.lastPauseTime = new Date();\n      clearInterval(this.timerId);\n      clearTimeout(this.resumeId);\n      this.state = exports.IntervalState.PAUSED;\n    };\n    /**\n     * `resume` calculates the remaining time for the callback to trigger using the values\n     * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n     * as the timeout delay.\n     */\n    this.resume = () => {\n      if (this.state !== exports.IntervalState.PAUSED) return;\n      const currentDate = new Date();\n      this.pausedTime = +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n      this.state = exports.IntervalState.RESUME;\n      this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n    };\n    /**\n     * Set a new interval to use on the next interval loop.\n     */\n    this.setInterval = newInterval => {\n      if (this.state === 1) {\n        // If running we need to instantiate (new ID) the variable.\n        this.pause();\n        this.interval = newInterval;\n        this.resume();\n      } else {\n        // If stopped, idle, or paused then switch it.\n        this.interval = newInterval;\n      }\n    };\n    /**\n     * Maximum amount of times the `callback` member will execute, it's infinite by default.\n     */\n    this.setMaxFires = newMax => {\n      if (newMax != null && this.fires >= newMax) {\n        this.stop();\n      }\n      this.maxFires = newMax;\n    };\n  }\n  static new(callback, interval) {\n    let maxFires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    if (!this.instance) this.instance = new IntervalTimer(callback, interval, maxFires);else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\nexports[\"default\"] = IntervalTimer;","map":{"version":3,"sources":["../../src/modules/IntervalTimer.ts"],"names":["IntervalState"],"mappings":"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","sourcesContent":["export enum IntervalState {\n  IDLE,\n  RUNNING,\n  PAUSED,\n  RESUME\n}\n\n/**\n * `IntervalTimer` is a class that handles logic for intervals, e.g. start stop, reset, resume, pause & maximum amount of fires.\n */\nexport default class IntervalTimer {\n  /**\n   * The state to handle logic.\n   * - 0 means the interval is idle.\n   * - 1 means it's running.\n   * - 2 means it's paused\n   * - 3 will resume.\n   */\n  public state: IntervalState = IntervalState.IDLE;\n\n  /**\n   * Remaining time before the next interval.\n   */\n  public remaining: number = 0;\n\n  /**\n   * Amount of times fired.\n   */\n  public fires: number = 0;\n\n  /**\n   * Time passed after pausing,\n   */\n  public pausedTime: number | Date = 0;\n\n  private lastTimeFired?: Date;\n  private timerId?: NodeJS.Timer;\n  private resumeId?: NodeJS.Timeout;\n  private lastPauseTime?: Date;\n\n  private constructor(\n    /**\n     * Called after every interval.\n     */\n    public callback: () => void,\n    /**\n     * Time between intervals, in milliseconds.\n     */\n    public interval: number,\n    /**\n     * Maximum amount of fires.\n     */\n    public maxFires?: number\n  ) {}\n\n  /**\n   * Handles the callback execution, the amount of fires, & the times when fired.\n   * If `this.maxFires` is **not** null, and it's bigger than `this.fires` and if `this.fires` exists, meaning if it the interval was at least started once before, then never fire again.\n   */\n  private intervalHandler = () => {\n    if (\n      this.maxFires != null &&\n      this.fires !== 0 &&\n      this.fires >= this.maxFires\n    ) {\n      this.stop();\n    } else {\n      this.lastTimeFired = new Date();\n      this.fires += 1;\n      this.callback();\n    }\n  };\n\n  /**\n   * `timeoutHandler` is executed by `resume`. `timeoutHandler` is the callback of a new `setTimeout` executed by `resume` to mimic a resume function.\n   * The callback is executed by running `intervalHandler`, and then `start` is executed to run a new interval.\n   */\n  private timeoutHandler = () => {\n    if (this.state !== IntervalState.RESUME) return;\n\n    this.pausedTime = 0;\n    this.intervalHandler();\n    this.start();\n  };\n\n  /**\n   * `start` executes the interval, and saves the interval ID for further use.\n   * The time of execution is also fired in case it's paused later on. The state\n   * is finally set as running.\n   */\n  public start = () => {\n    this.timerId = setInterval(this.intervalHandler, this.interval);\n    this.lastTimeFired = new Date();\n    this.state = IntervalState.RUNNING;\n  };\n\n  /**\n   * `stop` clears every respective timeout and interval, then sets the state as idle.\n   */\n  public stop = () => {\n    if (this.state === 0) return;\n\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.IDLE;\n  };\n\n  /**\n   * Resets the interval.\n   */\n  public reset = () => {\n    this.stop();\n    this.start();\n  };\n\n  /**\n   * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it\n   * in a member variable. Afterwards clear the respective timeout and interval then set the new\n   * state.\n   */\n  public pause = () => {\n    if (\n      this.state !== IntervalState.RUNNING &&\n      this.state !== IntervalState.RESUME\n    )\n      return;\n\n    this.remaining =\n      +this.interval -\n      (+new Date() - +(this.lastTimeFired || 0)) +\n      +this.pausedTime;\n    this.lastPauseTime = new Date();\n    clearInterval(this.timerId);\n    clearTimeout(this.resumeId);\n    this.state = IntervalState.PAUSED;\n  };\n\n  /**\n   * `resume` calculates the remaining time for the callback to trigger using the values\n   * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time\n   * as the timeout delay.\n   */\n  public resume = () => {\n    if (this.state !== IntervalState.PAUSED) return;\n    const currentDate = new Date();\n    this.pausedTime =\n      +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);\n    this.state = IntervalState.RESUME;\n    this.resumeId = setTimeout(this.timeoutHandler, this.remaining);\n  };\n\n  /**\n   * Set a new interval to use on the next interval loop.\n   */\n  public setInterval = (newInterval: number) => {\n    if (this.state === 1) {\n      // If running we need to instantiate (new ID) the variable.\n      this.pause();\n      this.interval = newInterval;\n      this.resume();\n    } else {\n      // If stopped, idle, or paused then switch it.\n      this.interval = newInterval;\n    }\n  };\n\n  /**\n   * Maximum amount of times the `callback` member will execute, it's infinite by default.\n   */\n  public setMaxFires = (newMax: number) => {\n    if (newMax != null && this.fires >= newMax) {\n      this.stop();\n    }\n    this.maxFires = newMax;\n  };\n\n  private static instance: IntervalTimer | undefined;\n\n  public static new(\n    callback: () => void,\n    interval: number,\n    maxFires: number | undefined = undefined\n  ): IntervalTimer {\n    if (!this.instance)\n      this.instance = new IntervalTimer(callback, interval, maxFires);\n    else {\n      this.instance.callback = callback;\n      this.instance.interval = interval;\n      this.instance.maxFires = maxFires;\n    }\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}