{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar jsxRuntime = require('react/jsx-runtime');\nvar React = require('react');\nvar ConsoleLogger = require('./ConsoleLogger.js');\nvar Controller = require('./Controller.js');\nvar IntersectionObserver = require('./IntersectionObserver.js');\nvar IntervalTimer = require('./IntervalTimer.js');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nconst logger = ConsoleLogger[\"default\"].new();\nconst defaultProps = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\nconst AutoplayStateContext = React__default[\"default\"].createContext(undefined);\nfunction autoplayReducer(state, action) {\n  switch (action.type) {\n    case 'pause':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: true\n        });\n      }\n    case 'resume':\n      {\n        return Object.assign(Object.assign({}, state), {\n          isPausedByUser: false\n        });\n      }\n    case 'set-debounce-timeout':\n      {\n        return Object.assign(Object.assign({}, state), {\n          debounceTimeout: action.payload\n        });\n      }\n    default:\n      {\n        throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n      }\n  }\n}\nfunction AutoplayProvider(_ref) {\n  let {\n    children,\n    autoplay\n  } = _ref;\n  var _a, _b;\n  const params = {\n    autoplayDuration: (_a = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : undefined) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,\n    autoplayDebounce: (_b = typeof autoplay === 'object' ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : undefined) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce\n  };\n  const [state, dispatch] = React__default[\"default\"].useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  });\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = Controller.useController();\n  const slidingCycleDuration = getSlidingCycleDuration();\n  const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);\n  if (params.autoplayDuration < getSlidingCycleDuration()) logger.warn('[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).', 'The sliding cycle duration will be used instead for the autoplay intervals.');\n  const autoplayInstance = IntervalTimer[\"default\"].new(() => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n  const {\n    isInView\n  } = IntersectionObserver.useIntersectionObserver();\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = () => {\n    const isPausedOrIdle = autoplayInstance.state === IntervalTimer.IntervalState.IDLE || state.isPausedByUser;\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n    autoplayInstance.pause();\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = () => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({\n      type: 'pause'\n    });\n  };\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = () => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({\n      type: 'resume'\n    });\n  };\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React__default[\"default\"].useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React__default[\"default\"].useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalTimer.IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalTimer.IntervalState.IDLE:\n          {\n            autoplayInstance.start();\n            logger.debug('[Autoplay] Started.');\n            break;\n          }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalTimer.IntervalState.PAUSED:\n          {\n            autoplayInstance.resume();\n            logger.debug('[Autoplay] Resumed.');\n            break;\n          }\n      }\n    } else if (autoplayInstance.state !== IntervalTimer.IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React__default[\"default\"].useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React__default[\"default\"].useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n  return jsxRuntime.jsx(AutoplayStateContext.Provider, Object.assign({\n    value: value\n  }, {\n    children: children\n  }));\n}\nfunction useAutoplay() {\n  const context = React__default[\"default\"].useContext(AutoplayStateContext);\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n  return context;\n}\nexports.AutoplayProvider = AutoplayProvider;\nexports.useAutoplay = useAutoplay;","map":{"version":3,"sources":["../../src/modules/Autoplay.tsx"],"names":["ConsoleLogger","React","useController","IntervalTimer","useIntersectionObserver","IntervalState","_jsx"],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport ConsoleLogger from './ConsoleLogger';\nimport { useController } from './Controller';\nimport { useIntersectionObserver } from './IntersectionObserver';\nimport IntervalTimer, { IntervalState } from './IntervalTimer';\n\nconst logger = ConsoleLogger.new();\n\ninterface Props {\n  /**\n   * Autoplay duration, interval or duration betweens slide transitions, in milliseconds.\n   * If it's lower than the sliding cycle duration (sliding duration + sliding delay), then the sliding cycle duration will be used instead.\n   * @default 8000\n   */\n  autoplayDuration?: number;\n  /**\n   * Time (in milliseconds) in which the autoplay will be debounced if the user interacts with the slider.\n   * The autoplay resumes if the user stops interacting after this duration.\n   * Set as 0 to disable this feature.\n   * @default 4000\n   */\n  autoplayDebounce?: number;\n}\n\nexport type AutoplayProps = Props | boolean;\n\ntype Action =\n  | { type: 'pause' }\n  | { type: 'resume' }\n  | { type: 'set-debounce-timeout'; payload: NodeJS.Timeout };\ninterface State {\n  isPausedByUser: boolean;\n  debounceTimeout?: NodeJS.Timeout;\n}\ntype ProviderProps = React.PropsWithChildren<{\n  autoplay?: AutoplayProps;\n}>;\n\nconst defaultProps: Required<Props> = {\n  autoplayDuration: 8000,\n  autoplayDebounce: 4000\n};\n\nconst AutoplayStateContext = React.createContext<\n  | {\n      state: State;\n      autoplayState: IntervalState;\n      debounce: () => void;\n      pause: () => void;\n      resume: () => void;\n    }\n  | undefined\n>(undefined);\n\nfunction autoplayReducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'pause': {\n      return { ...state, isPausedByUser: true };\n    }\n    case 'resume': {\n      return { ...state, isPausedByUser: false };\n    }\n    case 'set-debounce-timeout': {\n      return { ...state, debounceTimeout: action.payload };\n    }\n    default: {\n      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);\n    }\n  }\n}\n\nfunction AutoplayProvider({ children, autoplay }: ProviderProps) {\n  const params: Required<Props> = {\n    autoplayDuration:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDuration : undefined) ??\n      defaultProps.autoplayDuration,\n    autoplayDebounce:\n      (typeof autoplay === 'object' ? autoplay?.autoplayDebounce : undefined) ??\n      defaultProps.autoplayDebounce\n  };\n\n  const [state, dispatch] = React.useReducer(autoplayReducer, {\n    isPausedByUser: false,\n    debounceTimeout: undefined\n  } as State);\n\n  const {\n    state: controller,\n    changeSlide,\n    getNextSlide,\n    getSlidingCycleDuration\n  } = useController();\n\n  const slidingCycleDuration = getSlidingCycleDuration();\n\n  const autoplayCycleDuration = Math.max(\n    slidingCycleDuration,\n    params.autoplayDuration\n  );\n\n  if (params.autoplayDuration < getSlidingCycleDuration())\n    logger.warn(\n      '[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).',\n      'The sliding cycle duration will be used instead for the autoplay intervals.'\n    );\n\n  const autoplayInstance = IntervalTimer.new((): void => {\n    changeSlide(getNextSlide(controller.activeSlide));\n  }, autoplayCycleDuration);\n\n  const { isInView } = useIntersectionObserver();\n\n  /**\n   * Debounces the autoplay interval whene called.\n   */\n  const debounce = (): void => {\n    const isPausedOrIdle =\n      autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;\n\n    if (isPausedOrIdle) return; // If the slider has been paused, do nothing.\n\n    autoplayInstance.pause();\n\n    if (state.debounceTimeout) clearTimeout(state.debounceTimeout);\n\n    dispatch({\n      type: 'set-debounce-timeout',\n      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)\n    });\n  };\n\n  /**\n   * Pauses the autoplay.\n   */\n  const pause = (): void => {\n    logger.debug('[Autoplay] Paused by user.');\n    autoplayInstance.pause();\n    dispatch({ type: 'pause' });\n  };\n\n  /**\n   * Resumes the autoplay.\n   */\n  const resume = (): void => {\n    logger.debug('[Autoplay] Resumed by user.');\n    autoplayInstance.resume();\n    dispatch({ type: 'resume' });\n  };\n\n  /**\n   * When the user pauses the slider, clear any debounced timeouts.\n   */\n  React.useEffect(() => {\n    if (state.isPausedByUser) clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [state.isPausedByUser]);\n\n  /**\n   * Subscribe to changes in `autoplay` and `isInView`.\n   * If the slider goes out of the viewport, then pause the slider autoplay instance if it's not idle.\n   * If it comes back into viewport and its idle, start or resume the autoplay instance.\n   * If the autoplay is disabled, then stop.\n   */\n  React.useEffect(() => {\n    if (autoplay) {\n      switch (true) {\n        case state.isPausedByUser:\n          break;\n        // When not in view, stop the autoplay.\n        case !isInView && autoplayInstance.state !== IntervalState.IDLE:\n          autoplayInstance.stop();\n          logger.debug('[Autoplay] Stopped.');\n          break;\n        // When in view and idle, start it.\n        case isInView && autoplayInstance.state === IntervalState.IDLE: {\n          autoplayInstance.start();\n          logger.debug('[Autoplay] Started.');\n          break;\n        }\n        // When in view and paused, resume it.\n        case isInView && autoplayInstance.state === IntervalState.PAUSED: {\n          autoplayInstance.resume();\n          logger.debug('[Autoplay] Resumed.');\n          break;\n        }\n      }\n    } else if (autoplayInstance.state !== IntervalState.IDLE) {\n      autoplayInstance.stop();\n      logger.info('[Autoplay] Stopped.');\n    }\n  }, [autoplay, isInView]);\n\n  /**\n   * Clearing any existing timeouts to avoid memory leaks, and clear event listener.\n   */\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(state.debounceTimeout);\n      autoplayInstance.stop();\n    };\n  }, []);\n\n  /**\n   * When the slide changes, clear any debounced timeouts, after the slide finishes, the\n   * autoplay resets.\n   */\n  React.useEffect(() => {\n    clearTimeout(state.debounceTimeout);\n    return () => {};\n  }, [controller.activeSlide]);\n\n  // NOTE: you *might* need to memoize this value\n  // Learn more in http://kcd.im/optimize-context\n  const value = {\n    state,\n    autoplayState: autoplayInstance.state,\n    debounce,\n    pause,\n    resume\n  };\n\n  return (\n    <AutoplayStateContext.Provider value={value}>\n      {children}\n    </AutoplayStateContext.Provider>\n  );\n}\n\nfunction useAutoplay() {\n  const context = React.useContext(AutoplayStateContext);\n\n  if (context === undefined) {\n    throw new Error('useAutoplay must be used within a AutoplayProvider');\n  }\n\n  return context;\n}\n\nexport { AutoplayProvider, useAutoplay };\n"]},"metadata":{},"sourceType":"script"}